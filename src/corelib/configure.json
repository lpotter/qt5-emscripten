{
    "module": "core",
    "testDir": "../../config.tests",

    "commandline": {
        "options": {
            "doubleconversion": { "type": "enum", "values": [ "no", "qt", "system" ] },
            "eventfd": "boolean",
            "glib": "boolean",
            "iconv": { "type": "enum", "values": [ "no", "yes", "posix", "sun", "gnu" ] },
            "icu": "boolean",
            "inotify": "boolean",
            "journald": "boolean",
            "pcre": { "type": "enum", "values": [ "qt", "system" ] },
            "posix-ipc": { "type": "boolean", "name": "ipc_posix" },
            "pps": { "type": "boolean", "name": "qqnx_pps" },
            "slog2": "boolean",
            "syslog": "boolean",
            "trace": { "type": "optionalString", "values": [ "etw", "lttng", "no", "yes" ] }
        }
    },

    "libraries": {
        "doubleconversion": {
            "label": "DoubleConversion",
            "test": {
                "include": "double-conversion/double-conversion.h",
                "main": "(void) double_conversion::StringToDoubleConverter::NO_FLAGS;"
            },
            "sources": [
                "-ldouble-conversion"
            ]
        },
        "glib": {
            "label": "GLib",
            "test": {
                "head": "typedef struct _GMainContext GMainContext;",
                "include": "glib.h",
                "main": [
                    "g_thread_init(NULL);",
                    "(void) g_main_context_default();",
                    "(void) g_source_new(0, 0);",
                    "g_source_add_poll(NULL, NULL);"
                ]
            },
            "sources": [
                { "type": "pkgConfig", "args": "glib-2.0 gthread-2.0" }
            ]
        },
        "gnu_iconv": {
            "label": "GNU libiconv",
            "export": "iconv",
            "test": "gnu-libiconv",
            "sources": [
                "-liconv"
            ]
        },
        "icu": {
            "label": "ICU",
            "test": {
                "include": [ "unicode/utypes.h", "unicode/ucol.h", "unicode/ustring.h" ],
                "main": [
                    "UErrorCode status = U_ZERO_ERROR;",
                    "UCollator *collator = ucol_open(\"ru_RU\", &status);",
                    "if (!U_FAILURE(status))",
                    "    ucol_close(collator);"
                ]
            },
            "sources": [
                {
                    "builds": {
                        "debug": "-lsicuind -lsicuucd -lsicudtd",
                        "release": "-lsicuin -lsicuuc -lsicudt"
                    },
                    "condition": "config.win32 && !features.shared"
                },
                { "libs": "-licuin -licuuc -licudt", "condition": "config.win32 && features.shared" },
                { "libs": "-licui18n -licuuc -licudata", "condition": "!config.win32" }
            ],
            "use": [
                { "lib": "libdl", "condition": "features.dlopen" }
            ]
        },
        "journald": {
            "label": "journald",
            "test": {
                "include": [ "systemd/sd-journal.h", "syslog.h" ],
                "main": "sd_journal_send(\"PRIORITY=%i\", LOG_INFO, NULL);"
            },
            "sources": [
                { "type": "pkgConfig", "args": "libsystemd" },
                { "type": "pkgConfig", "args": "libsystemd-journal" }
            ]
        },
        "libatomic": {
            "label": "64 bit atomics",
            "test": {
                "include": [ "atomic", "cstdint" ],
                "tail": [
                    "void test(volatile std::atomic<std::int64_t> &a)",
                    "{",
                    "    std::int64_t v = a.load(std::memory_order_acquire);",
                    "    while (!a.compare_exchange_strong(v, v + 1,",
                    "                                      std::memory_order_acq_rel,",
                    "                                      std::memory_order_acquire)) {",
                    "        v = a.exchange(v - 1);",
                    "    }",
                    "    a.store(v + 1, std::memory_order_release);",
                    "}"
                ],
                "main": [
                    "void *ptr = (void*)0xffffffc0; // any random pointer",
                    "test(*reinterpret_cast<std::atomic<std::int64_t> *>(ptr));"
                ],
                "qmake": "CONFIG += c++11"
            },
            "sources": [
                "",
                "-latomic"
            ]
        },
        "libdl": {
            "label": "dlopen()",
            "test": {
                "include": "dlfcn.h",
                "main": [
                    "dlclose(dlopen(0, 0));",
                    "dlsym(RTLD_DEFAULT, 0);",
                    "dlerror();"
                ]
            },
            "sources": [
                "",
                "-ldl"
            ]
        },
        "librt": {
            "label": "clock_gettime()",
            "test": {
                "include": [ "unistd.h", "time.h" ],
                "main": "timespec ts; clock_gettime(CLOCK_REALTIME, &ts);"
            },
            "sources": [
                "",
                "-lrt"
            ]
        },
        "lttng-ust": {
            "label": "lttng-ust",
            "test": {
                "include": "lttng/ust-events.h",
                "main": "lttng_session_destroy(nullptr);"
            },
            "sources": [
                { "type": "pkgConfig", "args": "lttng-ust" },
                "-llttng-ust"
            ],
            "use": "libdl"
        },
        "pcre2": {
            "label": "PCRE2",
            "test": {
                "head": "#define PCRE2_CODE_UNIT_WIDTH 16",
                "include": "pcre2.h",
                "tail": [
                    "#if (PCRE2_MAJOR < 10) || ((PCRE2_MAJOR == 10) && (PCRE2_MINOR < 20))",
                    "#  error This PCRE version is not supported",
                    "#endif"
                ]
            },
            "sources": [
                { "type": "pkgConfig", "args": "libpcre2-16" },
                "-lpcre2-16"
            ]
        },
        "pps": {
            "label": "PPS",
            "test": {
                "include": "sys/pps.h",
                "main": [
                    "pps_decoder_t decoder;",
                    "pps_decoder_initialize(&decoder, NULL);"
                ]
            },
            "sources": [
                "-lpps"
            ]
        },
        "slog2": {
            "label": "slog2",
            "test": {
                "include": "sys/slog2.h",
                "main": "slog2_set_default_buffer((slog2_buffer_t)-1);"
            },
            "export": "",
            "sources": [
                "-lslog2"
            ]
        }
    },

    "tests": {
        "atomicfptr": {
            "label": "working std::atomic for function pointers",
            "type": "compile",
            "test": {
                "include": "atomic",
                "tail": [
                    "typedef void (*fptr)(int);",
                    "typedef std::atomic<fptr> atomicfptr;",
                    "void testfunction(int) { }",
                    "void test(volatile atomicfptr &a)",
                    "{",
                    "    fptr v = a.load(std::memory_order_acquire);",
                    "    while (!a.compare_exchange_strong(v, &testfunction,",
                    "                                      std::memory_order_acq_rel,",
                    "                                      std::memory_order_acquire)) {",
                    "        v = a.exchange(&testfunction);",
                    "    }",
                    "    a.store(&testfunction, std::memory_order_release);",
                    "}"
                ],
                "main": [
                    "atomicfptr fptr(testfunction);",
                    "test(fptr);"
                ],
                "qmake": "CONFIG += c++11"
            }
        },
        "clock-monotonic": {
            "label": "POSIX monotonic clock",
            "type": "compile",
            "test": {
                "include": [ "unistd.h", "time.h" ],
                "main": [
                    "#if defined(_POSIX_MONOTONIC_CLOCK) && (_POSIX_MONOTONIC_CLOCK-0 >= 0)",
                    "timespec ts;",
                    "clock_gettime(CLOCK_MONOTONIC, &ts);",
                    "#else",
                    "#  error Feature _POSIX_MONOTONIC_CLOCK not available",
                    "#endif"
                ]
            },
            "use": "librt"
        },
        "cloexec": {
            "label": "O_CLOEXEC",
            "type": "compile",
            "test": {
                "head": "#define _GNU_SOURCE 1",
                "include": [ "sys/types.h", "sys/socket.h", "fcntl.h", "unistd.h" ],
                "main": [
                    "int pipes[2];",
                    "(void) pipe2(pipes, O_CLOEXEC | O_NONBLOCK);",
                    "(void) fcntl(0, F_DUPFD_CLOEXEC, 0);",
                    "(void) dup3(0, 3, O_CLOEXEC);",
                    "#if defined(__NetBSD__)",
                    "(void) paccept(0, 0, 0, NULL, SOCK_CLOEXEC | SOCK_NONBLOCK);",
                    "#else",
                    "(void) accept4(0, 0, 0, SOCK_CLOEXEC | SOCK_NONBLOCK);",
                    "#endif"
                ]
            }
        },
        "cxx11_future": {
            "label": "C++11 <future>",
            "type": "compile",
            "test": {
                "include": "future",
                "main": [
                    "std::future<int> f = std::async([]() { return 42; });",
                    "(void)f.get();"
                ],
                "qmake": "unix:LIBS += -lpthread"
            }
        },
        "cxx11_random": {
            "label": "C++11 <random>",
            "type": "compile",
            "test": "unix/cxx11_random"
        },
        "eventfd": {
            "label": "eventfd",
            "type": "compile",
            "test": {
                "include": "sys/eventfd.h",
                "main": [
                    "eventfd_t value;",
                    "int fd = eventfd(0, EFD_CLOEXEC);",
                    "eventfd_read(fd, &value);",
                    "eventfd_write(fd, value);"
                ]
            }
        },
        "futimens": {
            "label": "futimens()",
            "type": "compile",
            "test": "unix/futimens"
        },
        "futimes": {
            "label": "futimes()",
            "type": "compile",
            "test": "unix/futimes"
        },
        "getauxval": {
            "label": "getauxval()",
            "type": "compile",
            "test": "unix/getauxval"
        },
        "getentropy": {
            "label": "getentropy()",
            "type": "compile",
            "test": "unix/getentropy"
        },
        "posix-iconv": {
            "label": "POSIX iconv",
            "type": "compile",
            "test": "iconv"
        },
        "sun-iconv": {
            "label": "SUN libiconv",
            "type": "compile",
            "test": "sun-libiconv"
        },
        "inotify": {
            "label": "inotify",
            "type": "compile",
            "test": {
                "include": "sys/inotify.h",
                "main": [
                    "inotify_init();",
                    "inotify_add_watch(0, \"foobar\", IN_ACCESS);",
                    "inotify_rm_watch(0, 1);"
                ]
            }
        },
        "ipc_sysv": {
            "label": "SysV IPC",
            "type": "compile",
            "test": {
                "include": [ "sys/types.h", "sys/ipc.h", "sys/sem.h", "sys/shm.h", "fcntl.h" ],
                "main": [
                    "key_t unix_key = ftok(\"test\", 'Q');",
                    "semctl(semget(unix_key, 1, 0666 | IPC_CREAT | IPC_EXCL), 0, IPC_RMID, 0);",
                    "shmget(unix_key, 0, 0666 | IPC_CREAT | IPC_EXCL);",
                    "shmctl(0, 0, (struct shmid_ds *)(0));"
                ]
            }
        },
        "ipc_posix": {
            "label": "POSIX IPC",
            "type": "compile",
            "test": {
                "include": [ "sys/types.h", "sys/mman.h", "semaphore.h", "fcntl.h" ],
                "main": [
                    "sem_close(sem_open(\"test\", O_CREAT | O_EXCL, 0666, 0));",
                    "shm_open(\"test\", O_RDWR | O_CREAT | O_EXCL, 0666);",
                    "shm_unlink(\"test\");"
                ],
                "qmake": "linux: LIBS += -lpthread -lrt"
            }
        },
        "linkat": {
            "label": "linkat()",
            "type": "compile",
            "test": {
                "head": "#define _ATFILE_SOURCE 1",
                "include": [ "fcntl.h", "unistd.h" ],
                "main": "linkat(AT_FDCWD, \"foo\", AT_FDCWD, \"bar\", AT_SYMLINK_FOLLOW);"
            }
        },
        "ppoll": {
            "label": "ppoll()",
            "type": "compile",
            "test": {
                "include": [ "signal.h", "poll.h" ],
                "main": [
                    "struct pollfd pfd;",
                    "struct timespec ts;",
                    "sigset_t sig;",
                    "ppoll(&pfd, 1, &ts, &sig);"
                ]
            }
        },
        "pollts": {
            "label": "pollts()",
            "type": "compile",
            "test": {
                "include": [ "poll.h", "signal.h", "time.h" ],
                "main": [
                    "struct pollfd pfd;",
                    "struct timespec ts;",
                    "sigset_t sig;",
                    "pollts(&pfd, 1, &ts, &sig);"
                ]
            }
        },
        "poll": {
            "label": "poll()",
            "type": "compile",
            "test": {
                "include": "poll.h",
                "main": [
                    "struct pollfd pfd;",
                    "poll(&pfd, 1, 0);"
                ]
            }
        },
        "renameat2": {
            "label": "renameat2()",
            "type": "compile",
            "test": {
                "head": "#define _ATFILE_SOURCE 1",
                "include": [ "fcntl.h", "stdio.h" ],
                "main": "renameat2(AT_FDCWD, argv[1], AT_FDCWD, argv[2], RENAME_NOREPLACE | RENAME_WHITEOUT);"
            }
        },
        "statx": {
            "label": "statx() in libc",
            "type": "compile",
            "test": {
                "head": "#define _ATFILE_SOURCE 1",
                "include": [ "sys/types.h", "sys/stat.h", "unistd.h", "fcntl.h" ],
                "main": [
                    "struct statx statxbuf;",
                    "unsigned int mask = STATX_BASIC_STATS;",
                    "return statx(AT_FDCWD, \"\", AT_STATX_SYNC_AS_STAT, mask, &statxbuf);"
                ]
            }
        },
        "syslog": {
            "label": "syslog",
            "type": "compile",
            "test": {
                "include": "syslog.h",
                "main": [
                    "openlog(\"qt\", 0, LOG_USER);",
                    "syslog(LOG_INFO, \"configure\");",
                    "closelog();"
                ]
            }
        },
        "xlocalescanprint": {
            "label": "xlocale.h (or equivalents)",
            "type": "compile",
            "test": "xlocalescanprint"
        }
    },

    "features": {
        "clock-gettime": {
            "label": "clock_gettime()",
            "condition": "config.unix && libs.librt",
            "output": [ "privateFeature" ]
        },
        "clock-monotonic": {
            "label": "POSIX monotonic clock",
            "condition": "features.clock-gettime && tests.clock-monotonic",
            "output": [ "feature" ]
        },
        "dlopen": {
            "label": "dlopen()",
            "condition": "config.unix && libs.libdl",
            "output": [ "privateFeature" ]
        },
        "doubleconversion": {
            "label": "DoubleConversion",
            "output": [ "privateFeature", "feature" ]
        },
        "system-doubleconversion": {
            "label": "  Using system DoubleConversion",
            "enable": "input.doubleconversion == 'system'",
            "disable": "input.doubleconversion == 'qt'",
            "condition": "features.doubleconversion && libs.doubleconversion",
            "output": [ "privateFeature" ]
        },
        "cxx11_future": {
            "label": "C++11 <future>",
            "condition": "tests.cxx11_future",
            "output": [ "publicFeature" ]
        },
        "eventfd": {
            "label": "eventfd",
            "condition": "!config.wasm && tests.eventfd",
            "output": [ "feature" ]
        },
        "futimens": {
            "label": "futimens()",
            "condition": "!config.win32 && tests.futimens",
            "output": [ "privateFeature" ]
        },
        "futimes": {
            "label": "futimes()",
            "condition": "!config.win32 && !features.futimens && tests.futimes",
            "output": [ "privateFeature" ]
        },
        "getauxval": {
            "label": "getauxval()",
            "condition": "config.linux && tests.getauxval",
            "output": [ "privateFeature" ]
        },
        "getentropy": {
            "label": "getentropy()",
            "condition": "config.unix && tests.getentropy",
            "output": [ "privateFeature" ]
        },
        "glib": {
            "label": "GLib",
            "autoDetect": "!config.win32",
            "condition": "libs.glib",
            "output": [ "privateFeature", "feature" ]
        },
        "iconv": {
            "label": "iconv",
            "purpose": "Provides internationalization on Unix.",
            "section": "Internationalization",
            "condition": "!features.icu && features.textcodec && (features.posix-libiconv || features.sun-libiconv || features.gnu-libiconv)",
            "output": [ "privateFeature", "feature" ]
        },
        "posix-libiconv": {
            "label": "POSIX iconv",
            "enable": "input.iconv == 'posix'",
            "disable": "input.iconv == 'sun' || input.iconv == 'gnu' || input.iconv == 'no'",
            "condition": "!config.win32 && !config.qnx && !config.android && !config.darwin && tests.posix-iconv",
            "output": [ "privateFeature" ]
        },
        "sun-libiconv": {
            "label": "SUN iconv",
            "enable": "input.iconv == 'sun'",
            "disable": "input.iconv == 'posix' || input.iconv == 'gnu' || input.iconv == 'no'",
            "condition": "!config.win32 && !config.qnx && !config.android && !config.darwin && !features.posix-libiconv && tests.sun-iconv"
        },
        "gnu-libiconv": {
            "label": "GNU iconv",
            "enable": "input.iconv == 'gnu'",
            "disable": "input.iconv == 'posix' || input.iconv == 'sun' || input.iconv == 'no'",
            "condition": "!config.win32 && !config.qnx && !config.android && !config.darwin && !features.posix-libiconv && !features.sun-libiconv && libs.gnu_iconv",
            "output": [ "privateFeature" ]
        },
        "icu": {
            "label": "ICU",
            "autoDetect": "!config.win32",
            "condition": "libs.icu",
            "output": [ "privateFeature" ]
        },
        "inotify": {
            "label": "inotify",
            "condition": "tests.inotify",
            "output": [ "privateFeature", "feature" ]
        },
        "ipc_posix": {
            "label": "Using POSIX IPC",
            "autoDetect": "!config.win32",
            "condition": "!tests.ipc_sysv && tests.ipc_posix",
            "output": [ { "type": "define", "name": "QT_POSIX_IPC" } ]
        },
        "journald": {
            "label": "journald",
            "autoDetect": false,
            "condition": "libs.journald",
            "output": [ "privateFeature" ]
        },
        "linkat": {
            "label": "linkat()",
            "comment": "Currently only used by QTemporaryFile; linkat() exists on Android, but hardlink creation fails due to security rules",
            "autoDetect": "config.linux && !config.android",
            "condition": "tests.linkat",
            "output": [ "privateFeature" ]
        },
        "std-atomic64": {
            "label": "64 bit atomic operations",
            "condition": "libs.libatomic",
            "output": [ "publicFeature" ]
        },
        "mimetype": {
            "label": "Mimetype handling",
            "purpose": "Provides MIME type handling.",
            "section": "Utilities",
            "condition": "features.textcodec",
            "output": [ "publicFeature", "feature" ]
        },
        "system-pcre2": {
            "label": "Using system PCRE2",
            "disable": "input.pcre == 'qt'",
            "enable": "input.pcre == 'system'",
            "condition": "libs.pcre2",
            "output": [
                "privateFeature",
                { "type": "privateConfig", "negative": true, "name": "pcre2" }
            ]
        },
        "poll_ppoll": {
            "label": "Native ppoll()",
            "emitIf": "!config.win32",
            "condition": "!config.wasm && tests.ppoll",
            "output": [ "privateFeature" ]
        },
        "poll_pollts": {
            "label": "Native pollts()",
            "emitIf": "!config.win32",
            "condition": "!features.poll_ppoll && tests.pollts",
            "output": [ "privateFeature" ]
        },
        "poll_poll": {
            "label": "Native poll()",
            "emitIf": "!config.win32",
            "condition": "!features.poll_ppoll && !features.poll_pollts && tests.poll",
            "output": [ "privateFeature" ]
        },
        "poll_select": {
            "label": "Emulated poll()",
            "emitIf": "!config.win32",
            "condition": "!features.poll_ppoll && !features.poll_pollts && !features.poll_poll",
            "output": [
                "privateFeature",
                { "type": "define", "name": "QT_NO_NATIVE_POLL" }
            ]
        },
        "qqnx_pps": {
            "label": "PPS",
            "emitIf": "config.qnx",
            "condition": "libs.pps",
            "output": [ "privateFeature" ]
        },
        "qeventtransition": {
            "label": "QEventTransition class",
            "condition": "features.statemachine",
            "output": [ "publicFeature" ]
        },
        "renameat2": {
            "label": "renameat2()",
            "condition": "config.linux && tests.renameat2",
            "output": [ "privateFeature" ]
        },
        "slog2": {
            "label": "slog2",
            "condition": "libs.slog2",
            "output": [ "privateFeature" ]
        },
        "statx": {
            "label": "statx() in libc",
            "condition": "config.linux && tests.statx",
            "output": [ "privateFeature" ]
        },
        "syslog": {
            "label": "syslog",
            "autoDetect": false,
            "condition": "tests.syslog",
            "output": [ "privateFeature" ]
        },
        "threadsafe-cloexec": {
            "label": "Threadsafe pipe creation",
            "condition": "tests.cloexec",
            "output": [
                "publicQtConfig",
                { "type": "define", "name": "QT_THREADSAFE_CLOEXEC", "value": 1 }
            ]
        },
        "properties": {
            "label": "Properties",
            "purpose": "Supports scripting Qt-based applications.",
            "section": "Kernel",
            "output": [ "publicFeature", "feature" ]
        },
        "regularexpression": {
            "label": "QRegularExpression",
            "purpose": "Provides an API to Perl-compatible regular expressions.",
            "section": "Kernel",
            "output": [ "publicFeature", "feature" ]
        },
        "sharedmemory": {
            "label": "QSharedMemory",
            "purpose": "Provides access to a shared memory segment.",
            "section": "Kernel",
            "condition": [
                "config.android || config.win32 || (!config.vxworks && (tests.ipc_sysv || tests.ipc_posix))"
            ],
            "output": [ "publicFeature", "feature" ]
        },
        "systemsemaphore": {
            "label": "QSystemSemaphore",
            "purpose": "Provides a general counting system semaphore.",
            "section": "Kernel",
            "condition": [
                "!config.integrity && !config.vxworks",
                "config.android || config.win32 || tests.ipc_sysv || tests.ipc_posix"
            ],
            "output": [ "publicFeature", "feature" ]
        },
        "xmlstream": {
            "label": "XML Streaming APIs",
            "purpose": "Provides a simple streaming API for XML.",
            "section": "Kernel",
            "output": [ "publicFeature", "feature" ]
        },
        "xmlstreamreader": {
            "label": "QXmlStreamReader",
            "purpose": "Provides a well-formed XML parser with a simple streaming API.",
            "section": "Kernel",
            "condition": "features.xmlstream",
            "output": [ "publicFeature", "feature" ]
        },
        "xmlstreamwriter": {
            "label": "QXmlStreamWriter",
            "purpose": "Provides a XML writer with a simple streaming API.",
            "section": "Kernel",
            "condition": "features.xmlstream",
            "output": [ "publicFeature", "feature" ]
        },
        "textdate": {
            "label": "Text Date",
            "purpose": "Supports month and day names in dates.",
            "section": "Data structures",
            "output": [ "publicFeature", "feature" ]
        },
        "datestring": {
            "label": "QDate/QTime/QDateTime",
            "purpose": "Provides convertion between dates and strings.",
            "section": "Data structures",
            "condition": "features.textdate",
            "output": [ "publicFeature", "feature" ]
        },
        "process": {
            "label": "QProcess",
            "purpose": "Supports external process invocation.",
            "section": "File I/O",
            "condition": "features.processenvironment && !config.winrt && !config.uikit && !config.integrity && !config.vxworks",
            "output": [ "publicFeature", "feature" ]
        },
        "processenvironment": {
            "label": "QProcessEnvironment",
            "purpose": "Provides a higher-level abstraction of environment variables.",
            "section": "File I/O",
            "condition": "!config.winrt && !config.integrity",
            "output": [ "publicFeature" ]
        },
        "temporaryfile": {
            "label": "QTemporaryFile",
            "purpose": "Provides an I/O device that operates on temporary files.",
            "section": "File I/O",
            "output": [ "publicFeature", "feature" ]
        },
        "library": {
            "label": "QLibrary",
            "purpose": "Provides a wrapper for dynamically loaded libraries.",
            "section": "File I/O",
            "condition": "config.win32 || config.hpux || (!config.nacl && features.dlopen)",
            "output": [ "publicFeature", "feature" ]
        },
        "settings": {
            "label": "QSettings",
            "purpose": "Provides persistent application settings.",
            "section": "File I/O",
            "output": [ "publicFeature", "feature" ]
        },
        "filesystemwatcher": {
            "label": "QFileSystemWatcher",
            "purpose": "Provides an interface for monitoring files and directories for modifications.",
            "section": "File I/O",
            "condition": "!config.winrt",
            "output": [ "publicFeature", "feature" ]
        },
        "filesystemiterator": {
            "label": "QFileSystemIterator",
            "purpose": "Provides fast file system iteration.",
            "section": "File I/O",
            "output": [ "publicFeature", "feature" ]
        },
        "itemmodel": {
            "label": "Qt Item Model",
            "purpose": "Provides the item model for item views",
            "section": "ItemViews",
            "output": [ "publicFeature", "feature" ]
        },
        "proxymodel": {
            "label": "QAbstractProxyModel",
            "purpose": "Supports processing of data passed between another model and a view.",
            "section": "ItemViews",
            "condition": "features.itemmodel",
            "output": [ "publicFeature", "feature" ]
        },
        "sortfilterproxymodel": {
            "label": "QSortFilterProxyModel",
            "purpose": "Supports sorting and filtering of data passed between another model and a view.",
            "section": "ItemViews",
            "condition": "features.proxymodel",
            "output": [ "publicFeature", "feature" ]
        },
        "identityproxymodel": {
            "label": "QIdentityProxyModel",
            "purpose": "Supports proxying a source model unmodified.",
            "section": "ItemViews",
            "condition": "features.proxymodel",
            "output": [ "publicFeature", "feature" ]
        },
        "stringlistmodel": {
            "label": "QStringListModel",
            "purpose": "Provides a model that supplies strings to views.",
            "section": "ItemViews",
            "condition": "features.itemmodel",
            "output": [ "publicFeature", "feature" ]
        },
        "translation": {
            "label": "Translation",
            "purpose": "Supports translations using QObject::tr().",
            "section": "Internationalization",
            "output": [ "publicFeature", "feature" ]
        },
        "textcodec": {
            "label": "QTextCodec",
            "purpose": "Supports conversions between text encodings.",
            "section": "Internationalization",
            "output": [ "publicFeature", "feature" ]
        },
        "codecs": {
            "label": "Codecs",
            "purpose": "Supports non-unicode text conversions.",
            "section": "Internationalization",
            "condition": "features.textcodec",
            "output": [ "publicFeature", "feature" ]
        },
        "big_codecs": {
            "label": "Big Codecs",
            "purpose": "Supports big codecs, e.g. CJK.",
            "section": "Internationalization",
            "condition": "features.textcodec",
            "output": [ "publicFeature", "feature" ]
        },
        "animation": {
            "label": "Animation",
            "purpose": "Provides a framework for animations.",
            "section": "Utilities",
            "condition": "features.properties",
            "output": [ "publicFeature", "feature" ]
        },
        "statemachine": {
            "label": "State machine",
            "purpose": "Provides hierarchical finite state machines.",
            "section": "Utilities",
            "condition": "features.properties",
            "output": [ "publicFeature", "feature" ]
        },
        "gestures": {
            "label": "Gesture",
            "purpose": "Provides a framework for gestures.",
            "section": "Utilities",
            "output": [ "publicFeature", "feature" ]
        },
        "sha3-fast": {
            "label": "Speed optimized SHA3",
            "purpose": "Optimizes SHA3 for speed instead of size.",
            "section": "Utilities",
            "output": [ "privateFeature" ]
        },
        "timezone": {
            "label": "QTimeZone",
            "purpose": "Provides support for time-zone handling.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "datetimeparser": {
            "label": "QDateTimeParser",
            "purpose": "Provides support for parsing date-time texts.",
            "section": "Utilities",
            "output": [ "privateFeature" ]
        },
        "commandlineparser": {
            "label": "QCommandlineParser",
            "purpose": "Provides support for command line parsing.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        },
        "lttng": {
            "label": "LTTNG",
            "autoDetect": false,
            "enable": "input.trace == 'lttng' || (input.trace =='yes' && config.linux)",
            "disable": "input.trace == 'etw' || input.trace =='no'",
            "condition": "config.linux && libs.lttng-ust",
            "output": [ "privateFeature" ]
        },
        "etw": {
            "label": "ETW",
            "autoDetect": false,
            "enable": "input.trace == 'etw' || (input.trace == 'yes' && config.win32)",
            "disable": "input.trace == 'lttng' || input.trace == 'no'",
            "condition": "config.win32",
            "output": [ "privateFeature" ]
        },
        "topleveldomain": {
            "label": "QUrl::topLevelDomain()",
            "purpose": "Provides support for extracting the top level domain from URLs.

If enabled, a binary dump of the Public Suffix List (http://www.publicsuffix.org,
Mozilla License) is included. The data is then also used in QNetworkCookieJar::validateCookie.",
            "section": "Utilities",
            "output": [ "publicFeature" ]
        }
    },

    "report": [
        {
            "type": "note",
            "condition": "features.journald || features.syslog || (config.qnx && features.slog2)",
            "message": "journald, syslog or slog2 integration is enabled.
If your users intend to develop applications against this build,
ensure that the IDEs they use either set QT_FORCE_STDERR_LOGGING to 1
or are able to read the logged output from journald, syslog or slog2."
        },
        {
            "type": "error",
            "condition": "!tests.cxx11_random",
            "message": "C++11 <random> is required and is missing or failed to compile."
        },
        {
            "type": "error",
            "condition": "input.doubleconversion == 'no' && !tests.xlocalescanprint",
            "message": "Your C library does not provide sscanf_l or snprintf_l.
You need to use libdouble-conversion for double/string conversion."
        },
        {
            "type": "error",
            "condition": "!tests.atomicfptr",
            "message": "detected a std::atomic implementation that fails for function pointers.
Please apply the patch corresponding to your Standard Library vendor, found in
  qtbase/config.tests/atomicfptr"
        }
    ],

    "summary": [
        {
            "section": "Qt Core",
            "entries": [
                "doubleconversion",
                "system-doubleconversion",
                "glib",
                "iconv",
                "icu",
                {
                    "message": "Tracing backend",
                    "type": "firstAvailableFeature",
                    "args": "etw lttng"
                },
                {
                    "section": "Logging backends",
                    "entries": [
                        "journald", "syslog", "slog2"
                    ]
                },
                {
                    "type": "feature",
                    "args": "qqnx_pps",
                    "condition": "config.qnx"
                },
                "system-pcre2"
            ]
        }
    ]
}
