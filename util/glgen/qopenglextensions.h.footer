
#else

class QOpenGLExtension_OES_EGL_imagePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP EGLImageTargetTexture2DOES)(GLenum target, GLeglImageOES image);
    void (QOPENGLF_APIENTRYP EGLImageTargetRenderbufferStorageOES)(GLenum target, GLeglImageOES image);
};

class QOpenGLExtension_OES_EGL_image : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_OES_EGL_image();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image);
    void glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_OES_EGL_image)
};

inline void QOpenGLExtension_OES_EGL_image::glEGLImageTargetTexture2DOES(GLenum target, GLeglImageOES image)
{
    Q_D(QOpenGLExtension_OES_EGL_image);
    d->EGLImageTargetTexture2DOES(target, image);
}

inline void QOpenGLExtension_OES_EGL_image::glEGLImageTargetRenderbufferStorageOES(GLenum target, GLeglImageOES image)
{
    Q_D(QOpenGLExtension_OES_EGL_image);
    d->EGLImageTargetRenderbufferStorageOES(target, image);
}

class QOpenGLExtension_OES_get_program_binaryPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP GetProgramBinaryOES)(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
    void (QOPENGLF_APIENTRYP ProgramBinaryOES)(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length);
};

class QOpenGLExtension_OES_get_program_binary : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_OES_get_program_binary();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary);
    void glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_OES_get_program_binary)
};

inline void QOpenGLExtension_OES_get_program_binary::glGetProgramBinaryOES(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, GLvoid *binary)
{
    Q_D(QOpenGLExtension_OES_get_program_binary);
    d->GetProgramBinaryOES(program, bufSize, length, binaryFormat, binary);
}

inline void QOpenGLExtension_OES_get_program_binary::glProgramBinaryOES(GLuint program, GLenum binaryFormat, const GLvoid *binary, GLint length)
{
    Q_D(QOpenGLExtension_OES_get_program_binary);
    d->ProgramBinaryOES(program, binaryFormat, binary, length);
}

class QOpenGLExtension_OES_mapbufferPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void* (QOPENGLF_APIENTRYP MapBufferOES)(GLenum target, GLenum access);
    GLboolean (QOPENGLF_APIENTRYP UnmapBufferOES)(GLenum target);
    void (QOPENGLF_APIENTRYP GetBufferPointervOES)(GLenum target, GLenum pname, GLvoid** params);
};

class QOpenGLExtension_OES_mapbuffer : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_OES_mapbuffer();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void* glMapBufferOES(GLenum target, GLenum access);
    GLboolean glUnmapBufferOES(GLenum target);
    void glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid** params);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_OES_mapbuffer)
};

inline void *QOpenGLExtension_OES_mapbuffer::glMapBufferOES(GLenum target, GLenum access)
{
    Q_D(QOpenGLExtension_OES_mapbuffer);
    return d->MapBufferOES(target, access);
}

inline GLboolean QOpenGLExtension_OES_mapbuffer::glUnmapBufferOES(GLenum target)
{
    Q_D(QOpenGLExtension_OES_mapbuffer);
    return d->UnmapBufferOES(target);
}

inline void QOpenGLExtension_OES_mapbuffer::glGetBufferPointervOES(GLenum target, GLenum pname, GLvoid** params)
{
    Q_D(QOpenGLExtension_OES_mapbuffer);
    d->GetBufferPointervOES(target, pname, params);
}

class QOpenGLExtension_OES_texture_3DPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP TexImage3DOES)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
    void (QOPENGLF_APIENTRYP TexSubImage3DOES)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels);
    void (QOPENGLF_APIENTRYP CopyTexSubImage3DOES)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    void (QOPENGLF_APIENTRYP CompressedTexImage3DOES)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
    void (QOPENGLF_APIENTRYP CompressedTexSubImage3DOES)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
    void (QOPENGLF_APIENTRYP FramebufferTexture3DOES)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
};

class QOpenGLExtension_OES_texture_3D : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_OES_texture_3D();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels);
    void glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels);
    void glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
    void glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data);
    void glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data);
    void glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_OES_texture_3D)
};

inline void QOpenGLExtension_OES_texture_3D::glTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid* pixels)
{
    Q_D(QOpenGLExtension_OES_texture_3D);
    d->TexImage3DOES(target, level, internalformat, width, height, depth, border, format, type, pixels);
}

inline void QOpenGLExtension_OES_texture_3D::glTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid* pixels)
{
    Q_D(QOpenGLExtension_OES_texture_3D);
    d->TexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}

inline void QOpenGLExtension_OES_texture_3D::glCopyTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_OES_texture_3D);
    d->CopyTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}

inline void QOpenGLExtension_OES_texture_3D::glCompressedTexImage3DOES(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid* data)
{
    Q_D(QOpenGLExtension_OES_texture_3D);
    d->CompressedTexImage3DOES(target, level, internalformat, width, height, depth, border, imageSize, data);
}

inline void QOpenGLExtension_OES_texture_3D::glCompressedTexSubImage3DOES(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid* data)
{
    Q_D(QOpenGLExtension_OES_texture_3D);
    d->CompressedTexSubImage3DOES(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}

inline void QOpenGLExtension_OES_texture_3D::glFramebufferTexture3DOES(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
{
    Q_D(QOpenGLExtension_OES_texture_3D);
    d->FramebufferTexture3DOES(target, attachment, textarget, texture, level, zoffset);
}

class QOpenGLExtension_OES_vertex_array_objectPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP BindVertexArrayOES)(GLuint array);
    void (QOPENGLF_APIENTRYP DeleteVertexArraysOES)(GLsizei n, const GLuint *arrays);
    void (QOPENGLF_APIENTRYP GenVertexArraysOES)(GLsizei n, GLuint *arrays);
    GLboolean (QOPENGLF_APIENTRYP IsVertexArrayOES)(GLuint array);
};

class QOpenGLExtension_OES_vertex_array_object : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_OES_vertex_array_object();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glBindVertexArrayOES(GLuint array);
    void glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays);
    void glGenVertexArraysOES(GLsizei n, GLuint *arrays);
    GLboolean glIsVertexArrayOES(GLuint array);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_OES_vertex_array_object)
};

inline void QOpenGLExtension_OES_vertex_array_object::glBindVertexArrayOES(GLuint array)
{
    Q_D(QOpenGLExtension_OES_vertex_array_object);
    d->BindVertexArrayOES(array);
}

inline void QOpenGLExtension_OES_vertex_array_object::glDeleteVertexArraysOES(GLsizei n, const GLuint *arrays)
{
    Q_D(QOpenGLExtension_OES_vertex_array_object);
    d->DeleteVertexArraysOES(n, arrays);
}

inline void QOpenGLExtension_OES_vertex_array_object::glGenVertexArraysOES(GLsizei n, GLuint *arrays)
{
    Q_D(QOpenGLExtension_OES_vertex_array_object);
    d->GenVertexArraysOES(n, arrays);
}

inline GLboolean QOpenGLExtension_OES_vertex_array_object::glIsVertexArrayOES(GLuint array)
{
    Q_D(QOpenGLExtension_OES_vertex_array_object);
    return d->IsVertexArrayOES(array);
}

class QOpenGLExtension_AMD_performance_monitorPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP GetPerfMonitorGroupsAMD)(GLint *numGroups, GLsizei groupsSize, GLuint *groups);
    void (QOPENGLF_APIENTRYP GetPerfMonitorCountersAMD)(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
    void (QOPENGLF_APIENTRYP GetPerfMonitorGroupStringAMD)(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
    void (QOPENGLF_APIENTRYP GetPerfMonitorCounterStringAMD)(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
    void (QOPENGLF_APIENTRYP GetPerfMonitorCounterInfoAMD)(GLuint group, GLuint counter, GLenum pname, GLvoid *data);
    void (QOPENGLF_APIENTRYP GenPerfMonitorsAMD)(GLsizei n, GLuint *monitors);
    void (QOPENGLF_APIENTRYP DeletePerfMonitorsAMD)(GLsizei n, GLuint *monitors);
    void (QOPENGLF_APIENTRYP SelectPerfMonitorCountersAMD)(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *countersList);
    void (QOPENGLF_APIENTRYP BeginPerfMonitorAMD)(GLuint monitor);
    void (QOPENGLF_APIENTRYP EndPerfMonitorAMD)(GLuint monitor);
    void (QOPENGLF_APIENTRYP GetPerfMonitorCounterDataAMD)(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);
};

class QOpenGLExtension_AMD_performance_monitor : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_AMD_performance_monitor();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups);
    void glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters);
    void glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString);
    void glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString);
    void glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data);
    void glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors);
    void glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors);
    void glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *countersList);
    void glBeginPerfMonitorAMD(GLuint monitor);
    void glEndPerfMonitorAMD(GLuint monitor);
    void glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_AMD_performance_monitor)
};

inline void QOpenGLExtension_AMD_performance_monitor::glGetPerfMonitorGroupsAMD(GLint *numGroups, GLsizei groupsSize, GLuint *groups)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GetPerfMonitorGroupsAMD(numGroups, groupsSize, groups);
}

inline void QOpenGLExtension_AMD_performance_monitor::glGetPerfMonitorCountersAMD(GLuint group, GLint *numCounters, GLint *maxActiveCounters, GLsizei counterSize, GLuint *counters)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GetPerfMonitorCountersAMD(group, numCounters, maxActiveCounters, counterSize, counters);
}

inline void QOpenGLExtension_AMD_performance_monitor::glGetPerfMonitorGroupStringAMD(GLuint group, GLsizei bufSize, GLsizei *length, GLchar *groupString)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GetPerfMonitorGroupStringAMD(group, bufSize, length, groupString);
}

inline void QOpenGLExtension_AMD_performance_monitor::glGetPerfMonitorCounterStringAMD(GLuint group, GLuint counter, GLsizei bufSize, GLsizei *length, GLchar *counterString)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GetPerfMonitorCounterStringAMD(group, counter, bufSize, length, counterString);
}

inline void QOpenGLExtension_AMD_performance_monitor::glGetPerfMonitorCounterInfoAMD(GLuint group, GLuint counter, GLenum pname, GLvoid *data)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GetPerfMonitorCounterInfoAMD(group, counter, pname, data);
}

inline void QOpenGLExtension_AMD_performance_monitor::glGenPerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GenPerfMonitorsAMD(n, monitors);
}

inline void QOpenGLExtension_AMD_performance_monitor::glDeletePerfMonitorsAMD(GLsizei n, GLuint *monitors)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->DeletePerfMonitorsAMD(n, monitors);
}

inline void QOpenGLExtension_AMD_performance_monitor::glSelectPerfMonitorCountersAMD(GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint *countersList)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->SelectPerfMonitorCountersAMD(monitor, enable, group, numCounters, countersList);
}

inline void QOpenGLExtension_AMD_performance_monitor::glBeginPerfMonitorAMD(GLuint monitor)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->BeginPerfMonitorAMD(monitor);
}

inline void QOpenGLExtension_AMD_performance_monitor::glEndPerfMonitorAMD(GLuint monitor)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->EndPerfMonitorAMD(monitor);
}

inline void QOpenGLExtension_AMD_performance_monitor::glGetPerfMonitorCounterDataAMD(GLuint monitor, GLenum pname, GLsizei dataSize, GLuint *data, GLint *bytesWritten)
{
    Q_D(QOpenGLExtension_AMD_performance_monitor);
    d->GetPerfMonitorCounterDataAMD(monitor, pname, dataSize, data, bytesWritten);
}

class QOpenGLExtension_ANGLE_framebuffer_blitPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP BlitFramebufferANGLE)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
};

class QOpenGLExtension_ANGLE_framebuffer_blit : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_ANGLE_framebuffer_blit();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_ANGLE_framebuffer_blit)
};

inline void QOpenGLExtension_ANGLE_framebuffer_blit::glBlitFramebufferANGLE(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
    Q_D(QOpenGLExtension_ANGLE_framebuffer_blit);
    d->BlitFramebufferANGLE(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}

class QOpenGLExtension_ANGLE_framebuffer_multisamplePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP RenderbufferStorageMultisampleANGLE)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
};

class QOpenGLExtension_ANGLE_framebuffer_multisample : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_ANGLE_framebuffer_multisample();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_ANGLE_framebuffer_multisample)
};

inline void QOpenGLExtension_ANGLE_framebuffer_multisample::glRenderbufferStorageMultisampleANGLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_ANGLE_framebuffer_multisample);
    d->RenderbufferStorageMultisampleANGLE(target, samples, internalformat, width, height);
}

class QOpenGLExtension_ANGLE_instanced_arraysPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP DrawArraysInstancedANGLE)(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
    void (QOPENGLF_APIENTRYP DrawElementsInstancedANGLE)(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
    void (QOPENGLF_APIENTRYP VertexAttribDivisorANGLE)(GLuint index, GLuint divisor);
};

class QOpenGLExtension_ANGLE_instanced_arrays : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_ANGLE_instanced_arrays();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
    void glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
    void glVertexAttribDivisorANGLE(GLuint index, GLuint divisor);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_ANGLE_instanced_arrays)
};

inline void QOpenGLExtension_ANGLE_instanced_arrays::glDrawArraysInstancedANGLE(GLenum mode, GLint first, GLsizei count, GLsizei primcount)
{
    Q_D(QOpenGLExtension_ANGLE_instanced_arrays);
    d->DrawArraysInstancedANGLE(mode, first, count, primcount);
}

inline void QOpenGLExtension_ANGLE_instanced_arrays::glDrawElementsInstancedANGLE(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount)
{
    Q_D(QOpenGLExtension_ANGLE_instanced_arrays);
    d->DrawElementsInstancedANGLE(mode, count, type, indices, primcount);
}

inline void QOpenGLExtension_ANGLE_instanced_arrays::glVertexAttribDivisorANGLE(GLuint index, GLuint divisor)
{
    Q_D(QOpenGLExtension_ANGLE_instanced_arrays);
    d->VertexAttribDivisorANGLE(index, divisor);
}

class QOpenGLExtension_ANGLE_translated_shader_sourcePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP GetTranslatedShaderSourceANGLE)(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source);
};

class QOpenGLExtension_ANGLE_translated_shader_source : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_ANGLE_translated_shader_source();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_ANGLE_translated_shader_source)
};

inline void QOpenGLExtension_ANGLE_translated_shader_source::glGetTranslatedShaderSourceANGLE(GLuint shader, GLsizei bufsize, GLsizei *length, GLchar *source)
{
    Q_D(QOpenGLExtension_ANGLE_translated_shader_source);
    d->GetTranslatedShaderSourceANGLE(shader, bufsize, length, source);
}

class QOpenGLExtension_APPLE_framebuffer_multisamplePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP RenderbufferStorageMultisampleAPPLE)(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
    void (QOPENGLF_APIENTRYP ResolveMultisampleFramebufferAPPLE)(void);
};

class QOpenGLExtension_APPLE_framebuffer_multisample : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_APPLE_framebuffer_multisample();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    void glResolveMultisampleFramebufferAPPLE(void);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_APPLE_framebuffer_multisample)
};

inline void QOpenGLExtension_APPLE_framebuffer_multisample::glRenderbufferStorageMultisampleAPPLE(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_APPLE_framebuffer_multisample);
    d->RenderbufferStorageMultisampleAPPLE(target, samples, internalformat, width, height);
}

inline void QOpenGLExtension_APPLE_framebuffer_multisample::glResolveMultisampleFramebufferAPPLE(void)
{
    Q_D(QOpenGLExtension_APPLE_framebuffer_multisample);
    d->ResolveMultisampleFramebufferAPPLE();
}

class QOpenGLExtension_EXT_debug_labelPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP LabelObjectEXT)(GLenum type, GLuint object, GLsizei length, const GLchar *label);
    void (QOPENGLF_APIENTRYP GetObjectLabelEXT)(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);
};

class QOpenGLExtension_EXT_debug_label : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_debug_label();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label);
    void glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_debug_label)
};

inline void QOpenGLExtension_EXT_debug_label::glLabelObjectEXT(GLenum type, GLuint object, GLsizei length, const GLchar *label)
{
    Q_D(QOpenGLExtension_EXT_debug_label);
    d->LabelObjectEXT(type, object, length, label);
}

inline void QOpenGLExtension_EXT_debug_label::glGetObjectLabelEXT(GLenum type, GLuint object, GLsizei bufSize, GLsizei *length, GLchar *label)
{
    Q_D(QOpenGLExtension_EXT_debug_label);
    d->GetObjectLabelEXT(type, object, bufSize, length, label);
}

class QOpenGLExtension_EXT_debug_markerPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP InsertEventMarkerEXT)(GLsizei length, const GLchar *marker);
    void (QOPENGLF_APIENTRYP PushGroupMarkerEXT)(GLsizei length, const GLchar *marker);
    void (QOPENGLF_APIENTRYP PopGroupMarkerEXT)(void);
};

class QOpenGLExtension_EXT_debug_marker : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_debug_marker();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glInsertEventMarkerEXT(GLsizei length, const GLchar *marker);
    void glPushGroupMarkerEXT(GLsizei length, const GLchar *marker);
    void glPopGroupMarkerEXT(void);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_debug_marker)
};

inline void QOpenGLExtension_EXT_debug_marker::glInsertEventMarkerEXT(GLsizei length, const GLchar *marker)
{
    Q_D(QOpenGLExtension_EXT_debug_marker);
    d->InsertEventMarkerEXT(length, marker);
}

inline void QOpenGLExtension_EXT_debug_marker::glPushGroupMarkerEXT(GLsizei length, const GLchar *marker)
{
    Q_D(QOpenGLExtension_EXT_debug_marker);
    d->PushGroupMarkerEXT(length, marker);
}

inline void QOpenGLExtension_EXT_debug_marker::glPopGroupMarkerEXT(void)
{
    Q_D(QOpenGLExtension_EXT_debug_marker);
    d->PopGroupMarkerEXT();
}

class QOpenGLExtension_EXT_discard_framebufferPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP DiscardFramebufferEXT)(GLenum target, GLsizei numAttachments, const GLenum *attachments);
};

class QOpenGLExtension_EXT_discard_framebuffer : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_discard_framebuffer();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_discard_framebuffer)
};

inline void QOpenGLExtension_EXT_discard_framebuffer::glDiscardFramebufferEXT(GLenum target, GLsizei numAttachments, const GLenum *attachments)
{
    Q_D(QOpenGLExtension_EXT_discard_framebuffer);
    d->DiscardFramebufferEXT(target, numAttachments, attachments);
}

class QOpenGLExtension_EXT_multisampled_render_to_texturePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP RenderbufferStorageMultisampleEXT)(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    void (QOPENGLF_APIENTRYP FramebufferTexture2DMultisampleEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);
};

class QOpenGLExtension_EXT_multisampled_render_to_texture : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_multisampled_render_to_texture();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    void glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_multisampled_render_to_texture)
};

inline void QOpenGLExtension_EXT_multisampled_render_to_texture::glRenderbufferStorageMultisampleEXT(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_EXT_multisampled_render_to_texture);
    d->RenderbufferStorageMultisampleEXT(target, samples, internalformat, width, height);
}

inline void QOpenGLExtension_EXT_multisampled_render_to_texture::glFramebufferTexture2DMultisampleEXT(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
    Q_D(QOpenGLExtension_EXT_multisampled_render_to_texture);
    d->FramebufferTexture2DMultisampleEXT(target, attachment, textarget, texture, level, samples);
}

class QOpenGLExtension_EXT_multi_draw_arraysPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP MultiDrawArraysEXT)(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
    void (QOPENGLF_APIENTRYP MultiDrawElementsEXT)(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);
};

class QOpenGLExtension_EXT_multi_draw_arrays : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_multi_draw_arrays();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glMultiDrawArraysEXT(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount);
    void glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_multi_draw_arrays)
};

inline void QOpenGLExtension_EXT_multi_draw_arrays::glMultiDrawArraysEXT(GLenum mode, GLint *first, GLsizei *count, GLsizei primcount)
{
    Q_D(QOpenGLExtension_EXT_multi_draw_arrays);
    d->MultiDrawArraysEXT(mode, first, count, primcount);
}

inline void QOpenGLExtension_EXT_multi_draw_arrays::glMultiDrawElementsEXT(GLenum mode, const GLsizei *count, GLenum type, const GLvoid* *indices, GLsizei primcount)
{
    Q_D(QOpenGLExtension_EXT_multi_draw_arrays);
    d->MultiDrawElementsEXT(mode, count, type, indices, primcount);
}

class QOpenGLExtension_EXT_occlusion_query_booleanPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP GenQueriesEXT)(GLsizei n, GLuint *ids);
    void (QOPENGLF_APIENTRYP DeleteQueriesEXT)(GLsizei n, const GLuint *ids);
    GLboolean (QOPENGLF_APIENTRYP IsQueryEXT)(GLuint id);
    void (QOPENGLF_APIENTRYP BeginQueryEXT)(GLenum target, GLuint id);
    void (QOPENGLF_APIENTRYP EndQueryEXT)(GLenum target);
    void (QOPENGLF_APIENTRYP GetQueryivEXT)(GLenum target, GLenum pname, GLint *params);
    void (QOPENGLF_APIENTRYP GetQueryObjectuivEXT)(GLuint id, GLenum pname, GLuint *params);
};

class QOpenGLExtension_EXT_occlusion_query_boolean : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_occlusion_query_boolean();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glGenQueriesEXT(GLsizei n, GLuint *ids);
    void glDeleteQueriesEXT(GLsizei n, const GLuint *ids);
    GLboolean glIsQueryEXT(GLuint id);
    void glBeginQueryEXT(GLenum target, GLuint id);
    void glEndQueryEXT(GLenum target);
    void glGetQueryivEXT(GLenum target, GLenum pname, GLint *params);
    void glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_occlusion_query_boolean)
};

inline void QOpenGLExtension_EXT_occlusion_query_boolean::glGenQueriesEXT(GLsizei n, GLuint *ids)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    d->GenQueriesEXT(n, ids);
}

inline void QOpenGLExtension_EXT_occlusion_query_boolean::glDeleteQueriesEXT(GLsizei n, const GLuint *ids)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    d->DeleteQueriesEXT(n, ids);
}

inline GLboolean QOpenGLExtension_EXT_occlusion_query_boolean::glIsQueryEXT(GLuint id)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    return d->IsQueryEXT(id);
}

inline void QOpenGLExtension_EXT_occlusion_query_boolean::glBeginQueryEXT(GLenum target, GLuint id)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    d->BeginQueryEXT(target, id);
}

inline void QOpenGLExtension_EXT_occlusion_query_boolean::glEndQueryEXT(GLenum target)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    d->EndQueryEXT(target);
}

inline void QOpenGLExtension_EXT_occlusion_query_boolean::glGetQueryivEXT(GLenum target, GLenum pname, GLint *params)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    d->GetQueryivEXT(target, pname, params);
}

inline void QOpenGLExtension_EXT_occlusion_query_boolean::glGetQueryObjectuivEXT(GLuint id, GLenum pname, GLuint *params)
{
    Q_D(QOpenGLExtension_EXT_occlusion_query_boolean);
    d->GetQueryObjectuivEXT(id, pname, params);
}

class QOpenGLExtension_EXT_robustnessPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    GLenum (QOPENGLF_APIENTRYP GetGraphicsResetStatusEXT)(void);
    void (QOPENGLF_APIENTRYP ReadnPixelsEXT)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
    void (QOPENGLF_APIENTRYP GetnUniformfvEXT)(GLuint program, GLint location, GLsizei bufSize, float *params);
    void (QOPENGLF_APIENTRYP GetnUniformivEXT)(GLuint program, GLint location, GLsizei bufSize, GLint *params);
};

class QOpenGLExtension_EXT_robustness : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_robustness();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    GLenum glGetGraphicsResetStatusEXT(void);
    void glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);
    void glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, float *params);
    void glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint *params);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_robustness)
};

inline GLenum QOpenGLExtension_EXT_robustness::glGetGraphicsResetStatusEXT(void)
{
    Q_D(QOpenGLExtension_EXT_robustness);
    return d->GetGraphicsResetStatusEXT();
}

inline void QOpenGLExtension_EXT_robustness::glReadnPixelsEXT(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data)
{
    Q_D(QOpenGLExtension_EXT_robustness);
    d->ReadnPixelsEXT(x, y, width, height, format, type, bufSize, data);
}

inline void QOpenGLExtension_EXT_robustness::glGetnUniformfvEXT(GLuint program, GLint location, GLsizei bufSize, float *params)
{
    Q_D(QOpenGLExtension_EXT_robustness);
    d->GetnUniformfvEXT(program, location, bufSize, params);
}

inline void QOpenGLExtension_EXT_robustness::glGetnUniformivEXT(GLuint program, GLint location, GLsizei bufSize, GLint *params)
{
    Q_D(QOpenGLExtension_EXT_robustness);
    d->GetnUniformivEXT(program, location, bufSize, params);
}

class QOpenGLExtension_EXT_separate_shader_objectsPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP UseProgramStagesEXT)(GLuint pipeline, GLbitfield stages, GLuint program);
    void (QOPENGLF_APIENTRYP ActiveShaderProgramEXT)(GLuint pipeline, GLuint program);
    GLuint (QOPENGLF_APIENTRYP CreateShaderProgramvEXT)(GLenum type, GLsizei count, const GLchar **strings);
    void (QOPENGLF_APIENTRYP BindProgramPipelineEXT)(GLuint pipeline);
    void (QOPENGLF_APIENTRYP DeleteProgramPipelinesEXT)(GLsizei n, const GLuint *pipelines);
    void (QOPENGLF_APIENTRYP GenProgramPipelinesEXT)(GLsizei n, GLuint *pipelines);
    GLboolean (QOPENGLF_APIENTRYP IsProgramPipelineEXT)(GLuint pipeline);
    void (QOPENGLF_APIENTRYP ProgramParameteriEXT)(GLuint program, GLenum pname, GLint value);
    void (QOPENGLF_APIENTRYP GetProgramPipelineivEXT)(GLuint pipeline, GLenum pname, GLint *params);
    void (QOPENGLF_APIENTRYP ProgramUniform1iEXT)(GLuint program, GLint location, GLint x);
    void (QOPENGLF_APIENTRYP ProgramUniform2iEXT)(GLuint program, GLint location, GLint x, GLint y);
    void (QOPENGLF_APIENTRYP ProgramUniform3iEXT)(GLuint program, GLint location, GLint x, GLint y, GLint z);
    void (QOPENGLF_APIENTRYP ProgramUniform4iEXT)(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
    void (QOPENGLF_APIENTRYP ProgramUniform1fEXT)(GLuint program, GLint location, GLfloat x);
    void (QOPENGLF_APIENTRYP ProgramUniform2fEXT)(GLuint program, GLint location, GLfloat x, GLfloat y);
    void (QOPENGLF_APIENTRYP ProgramUniform3fEXT)(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
    void (QOPENGLF_APIENTRYP ProgramUniform4fEXT)(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void (QOPENGLF_APIENTRYP ProgramUniform1ivEXT)(GLuint program, GLint location, GLsizei count, const GLint *value);
    void (QOPENGLF_APIENTRYP ProgramUniform2ivEXT)(GLuint program, GLint location, GLsizei count, const GLint *value);
    void (QOPENGLF_APIENTRYP ProgramUniform3ivEXT)(GLuint program, GLint location, GLsizei count, const GLint *value);
    void (QOPENGLF_APIENTRYP ProgramUniform4ivEXT)(GLuint program, GLint location, GLsizei count, const GLint *value);
    void (QOPENGLF_APIENTRYP ProgramUniform1fvEXT)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ProgramUniform2fvEXT)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ProgramUniform3fvEXT)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ProgramUniform4fvEXT)(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ProgramUniformMatrix2fvEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ProgramUniformMatrix3fvEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ProgramUniformMatrix4fvEXT)(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
    void (QOPENGLF_APIENTRYP ValidateProgramPipelineEXT)(GLuint pipeline);
    void (QOPENGLF_APIENTRYP GetProgramPipelineInfoLogEXT)(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
};

class QOpenGLExtension_EXT_separate_shader_objects : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_separate_shader_objects();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program);
    void glActiveShaderProgramEXT(GLuint pipeline, GLuint program);
    GLuint glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar **strings);
    void glBindProgramPipelineEXT(GLuint pipeline);
    void glDeleteProgramPipelinesEXT(GLsizei n, const GLuint *pipelines);
    void glGenProgramPipelinesEXT(GLsizei n, GLuint *pipelines);
    GLboolean glIsProgramPipelineEXT(GLuint pipeline);
    void glProgramParameteriEXT(GLuint program, GLenum pname, GLint value);
    void glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint *params);
    void glProgramUniform1iEXT(GLuint program, GLint location, GLint x);
    void glProgramUniform2iEXT(GLuint program, GLint location, GLint x, GLint y);
    void glProgramUniform3iEXT(GLuint program, GLint location, GLint x, GLint y, GLint z);
    void glProgramUniform4iEXT(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
    void glProgramUniform1fEXT(GLuint program, GLint location, GLfloat x);
    void glProgramUniform2fEXT(GLuint program, GLint location, GLfloat x, GLfloat y);
    void glProgramUniform3fEXT(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
    void glProgramUniform4fEXT(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
    void glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
    void glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
    void glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
    void glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value);
    void glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value);
    void glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
    void glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
    void glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
    void glValidateProgramPipelineEXT(GLuint pipeline);
    void glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_separate_shader_objects)
};

inline void QOpenGLExtension_EXT_separate_shader_objects::glUseProgramStagesEXT(GLuint pipeline, GLbitfield stages, GLuint program)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->UseProgramStagesEXT(pipeline, stages, program);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glActiveShaderProgramEXT(GLuint pipeline, GLuint program)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ActiveShaderProgramEXT(pipeline, program);
}

inline GLuint QOpenGLExtension_EXT_separate_shader_objects::glCreateShaderProgramvEXT(GLenum type, GLsizei count, const GLchar **strings)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    return d->CreateShaderProgramvEXT(type, count, strings);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glBindProgramPipelineEXT(GLuint pipeline)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->BindProgramPipelineEXT(pipeline);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glDeleteProgramPipelinesEXT(GLsizei n, const GLuint *pipelines)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->DeleteProgramPipelinesEXT(n, pipelines);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glGenProgramPipelinesEXT(GLsizei n, GLuint *pipelines)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->GenProgramPipelinesEXT(n, pipelines);
}

inline GLboolean QOpenGLExtension_EXT_separate_shader_objects::glIsProgramPipelineEXT(GLuint pipeline)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    return d->IsProgramPipelineEXT(pipeline);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramParameteriEXT(GLuint program, GLenum pname, GLint value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramParameteriEXT(program, pname, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glGetProgramPipelineivEXT(GLuint pipeline, GLenum pname, GLint *params)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->GetProgramPipelineivEXT(pipeline, pname, params);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform1iEXT(GLuint program, GLint location, GLint x)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform1iEXT(program, location, x);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform2iEXT(GLuint program, GLint location, GLint x, GLint y)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform2iEXT(program, location, x, y);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform3iEXT(GLuint program, GLint location, GLint x, GLint y, GLint z)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform3iEXT(program, location, x, y, z);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform4iEXT(GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform4iEXT(program, location, x, y, z, w);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform1fEXT(GLuint program, GLint location, GLfloat x)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform1fEXT(program, location, x);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform2fEXT(GLuint program, GLint location, GLfloat x, GLfloat y)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform2fEXT(program, location, x, y);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform3fEXT(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform3fEXT(program, location, x, y, z);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform4fEXT(GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform4fEXT(program, location, x, y, z, w);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform1ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform1ivEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform2ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform2ivEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform3ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform3ivEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform4ivEXT(GLuint program, GLint location, GLsizei count, const GLint *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform4ivEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform1fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform1fvEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform2fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform2fvEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform3fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform3fvEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniform4fvEXT(GLuint program, GLint location, GLsizei count, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniform4fvEXT(program, location, count, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniformMatrix2fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniformMatrix2fvEXT(program, location, count, transpose, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniformMatrix3fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniformMatrix3fvEXT(program, location, count, transpose, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glProgramUniformMatrix4fvEXT(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ProgramUniformMatrix4fvEXT(program, location, count, transpose, value);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glValidateProgramPipelineEXT(GLuint pipeline)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->ValidateProgramPipelineEXT(pipeline);
}

inline void QOpenGLExtension_EXT_separate_shader_objects::glGetProgramPipelineInfoLogEXT(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog)
{
    Q_D(QOpenGLExtension_EXT_separate_shader_objects);
    d->GetProgramPipelineInfoLogEXT(pipeline, bufSize, length, infoLog);
}

class QOpenGLExtension_EXT_texture_storagePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP TexStorage1DEXT)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
    void (QOPENGLF_APIENTRYP TexStorage2DEXT)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    void (QOPENGLF_APIENTRYP TexStorage3DEXT)(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
    void (QOPENGLF_APIENTRYP TextureStorage1DEXT)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
    void (QOPENGLF_APIENTRYP TextureStorage2DEXT)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    void (QOPENGLF_APIENTRYP TextureStorage3DEXT)(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
};

class QOpenGLExtension_EXT_texture_storage : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_EXT_texture_storage();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
    void glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    void glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
    void glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
    void glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
    void glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_EXT_texture_storage)
};

inline void QOpenGLExtension_EXT_texture_storage::glTexStorage1DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
    Q_D(QOpenGLExtension_EXT_texture_storage);
    d->TexStorage1DEXT(target, levels, internalformat, width);
}

inline void QOpenGLExtension_EXT_texture_storage::glTexStorage2DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_EXT_texture_storage);
    d->TexStorage2DEXT(target, levels, internalformat, width, height);
}

inline void QOpenGLExtension_EXT_texture_storage::glTexStorage3DEXT(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    Q_D(QOpenGLExtension_EXT_texture_storage);
    d->TexStorage3DEXT(target, levels, internalformat, width, height, depth);
}

inline void QOpenGLExtension_EXT_texture_storage::glTextureStorage1DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width)
{
    Q_D(QOpenGLExtension_EXT_texture_storage);
    d->TextureStorage1DEXT(texture, target, levels, internalformat, width);
}

inline void QOpenGLExtension_EXT_texture_storage::glTextureStorage2DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_EXT_texture_storage);
    d->TextureStorage2DEXT(texture, target, levels, internalformat, width, height);
}

inline void QOpenGLExtension_EXT_texture_storage::glTextureStorage3DEXT(GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth)
{
    Q_D(QOpenGLExtension_EXT_texture_storage);
    d->TextureStorage3DEXT(texture, target, levels, internalformat, width, height, depth);
}

class QOpenGLExtension_IMG_multisampled_render_to_texturePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP RenderbufferStorageMultisampleIMG)(GLenum, GLsizei, GLenum, GLsizei, GLsizei);
    void (QOPENGLF_APIENTRYP FramebufferTexture2DMultisampleIMG)(GLenum, GLenum, GLenum, GLuint, GLint, GLsizei);
};

class QOpenGLExtension_IMG_multisampled_render_to_texture : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_IMG_multisampled_render_to_texture();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
    void glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_IMG_multisampled_render_to_texture)
};

inline void QOpenGLExtension_IMG_multisampled_render_to_texture::glRenderbufferStorageMultisampleIMG(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
    Q_D(QOpenGLExtension_IMG_multisampled_render_to_texture);
    d->RenderbufferStorageMultisampleIMG(target, samples, internalformat, width, height);
}

inline void QOpenGLExtension_IMG_multisampled_render_to_texture::glFramebufferTexture2DMultisampleIMG(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLsizei samples)
{
    Q_D(QOpenGLExtension_IMG_multisampled_render_to_texture);
    d->FramebufferTexture2DMultisampleIMG(target, attachment, textarget, texture, level, samples);
}

class QOpenGLExtension_NV_coverage_samplePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP CoverageMaskNV)(GLboolean mask);
    void (QOPENGLF_APIENTRYP CoverageOperationNV)(GLenum operation);
};

class QOpenGLExtension_NV_coverage_sample : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_NV_coverage_sample();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glCoverageMaskNV(GLboolean mask);
    void glCoverageOperationNV(GLenum operation);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_NV_coverage_sample)
};

inline void QOpenGLExtension_NV_coverage_sample::glCoverageMaskNV(GLboolean mask)
{
    Q_D(QOpenGLExtension_NV_coverage_sample);
    d->CoverageMaskNV(mask);
}

inline void QOpenGLExtension_NV_coverage_sample::glCoverageOperationNV(GLenum operation)
{
    Q_D(QOpenGLExtension_NV_coverage_sample);
    d->CoverageOperationNV(operation);
}

class QOpenGLExtension_NV_draw_buffersPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP DrawBuffersNV)(GLsizei n, const GLenum *bufs);
};

class QOpenGLExtension_NV_draw_buffers : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_NV_draw_buffers();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glDrawBuffersNV(GLsizei n, const GLenum *bufs);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_NV_draw_buffers)
};

inline void QOpenGLExtension_NV_draw_buffers::glDrawBuffersNV(GLsizei n, const GLenum *bufs)
{
    Q_D(QOpenGLExtension_NV_draw_buffers);
    d->DrawBuffersNV(n, bufs);
}

class QOpenGLExtension_NV_fencePrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP DeleteFencesNV)(GLsizei n, const GLuint *fences);
    void (QOPENGLF_APIENTRYP GenFencesNV)(GLsizei n, GLuint *fences);
    GLboolean (QOPENGLF_APIENTRYP IsFenceNV)(GLuint fence);
    GLboolean (QOPENGLF_APIENTRYP TestFenceNV)(GLuint fence);
    void (QOPENGLF_APIENTRYP GetFenceivNV)(GLuint fence, GLenum pname, GLint *params);
    void (QOPENGLF_APIENTRYP FinishFenceNV)(GLuint fence);
    void (QOPENGLF_APIENTRYP SetFenceNV)(GLuint fence, GLenum condition);
};

class QOpenGLExtension_NV_fence : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_NV_fence();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glDeleteFencesNV(GLsizei n, const GLuint *fences);
    void glGenFencesNV(GLsizei n, GLuint *fences);
    GLboolean glIsFenceNV(GLuint fence);
    GLboolean glTestFenceNV(GLuint fence);
    void glGetFenceivNV(GLuint fence, GLenum pname, GLint *params);
    void glFinishFenceNV(GLuint fence);
    void glSetFenceNV(GLuint fence, GLenum condition);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_NV_fence)
};

inline void QOpenGLExtension_NV_fence::glDeleteFencesNV(GLsizei n, const GLuint *fences)
{
    Q_D(QOpenGLExtension_NV_fence);
    d->DeleteFencesNV(n, fences);
}

inline void QOpenGLExtension_NV_fence::glGenFencesNV(GLsizei n, GLuint *fences)
{
    Q_D(QOpenGLExtension_NV_fence);
    d->GenFencesNV(n, fences);
}

inline GLboolean QOpenGLExtension_NV_fence::glIsFenceNV(GLuint fence)
{
    Q_D(QOpenGLExtension_NV_fence);
    return d->IsFenceNV(fence);
}

inline GLboolean QOpenGLExtension_NV_fence::glTestFenceNV(GLuint fence)
{
    Q_D(QOpenGLExtension_NV_fence);
    return d->TestFenceNV(fence);
}

inline void QOpenGLExtension_NV_fence::glGetFenceivNV(GLuint fence, GLenum pname, GLint *params)
{
    Q_D(QOpenGLExtension_NV_fence);
    d->GetFenceivNV(fence, pname, params);
}

inline void QOpenGLExtension_NV_fence::glFinishFenceNV(GLuint fence)
{
    Q_D(QOpenGLExtension_NV_fence);
    d->FinishFenceNV(fence);
}

inline void QOpenGLExtension_NV_fence::glSetFenceNV(GLuint fence, GLenum condition)
{
    Q_D(QOpenGLExtension_NV_fence);
    d->SetFenceNV(fence, condition);
}

class QOpenGLExtension_NV_read_bufferPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP ReadBufferNV)(GLenum mode);
};

class QOpenGLExtension_NV_read_buffer : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_NV_read_buffer();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glReadBufferNV(GLenum mode);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_NV_read_buffer)
};

inline void QOpenGLExtension_NV_read_buffer::glReadBufferNV(GLenum mode)
{
    Q_D(QOpenGLExtension_NV_read_buffer);
    d->ReadBufferNV(mode);
}

class QOpenGLExtension_QCOM_alpha_testPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP AlphaFuncQCOM)(GLenum func, GLclampf ref);
};

class QOpenGLExtension_QCOM_alpha_test : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_QCOM_alpha_test();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glAlphaFuncQCOM(GLenum func, GLclampf ref);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_QCOM_alpha_test)
};

inline void QOpenGLExtension_QCOM_alpha_test::glAlphaFuncQCOM(GLenum func, GLclampf ref)
{
    Q_D(QOpenGLExtension_QCOM_alpha_test);
    d->AlphaFuncQCOM(func, ref);
}

class QOpenGLExtension_QCOM_driver_controlPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP GetDriverControlsQCOM)(GLint *num, GLsizei size, GLuint *driverControls);
    void (QOPENGLF_APIENTRYP GetDriverControlStringQCOM)(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString);
    void (QOPENGLF_APIENTRYP EnableDriverControlQCOM)(GLuint driverControl);
    void (QOPENGLF_APIENTRYP DisableDriverControlQCOM)(GLuint driverControl);
};

class QOpenGLExtension_QCOM_driver_control : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_QCOM_driver_control();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glGetDriverControlsQCOM(GLint *num, GLsizei size, GLuint *driverControls);
    void glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString);
    void glEnableDriverControlQCOM(GLuint driverControl);
    void glDisableDriverControlQCOM(GLuint driverControl);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_QCOM_driver_control)
};

inline void QOpenGLExtension_QCOM_driver_control::glGetDriverControlsQCOM(GLint *num, GLsizei size, GLuint *driverControls)
{
    Q_D(QOpenGLExtension_QCOM_driver_control);
    d->GetDriverControlsQCOM(num, size, driverControls);
}

inline void QOpenGLExtension_QCOM_driver_control::glGetDriverControlStringQCOM(GLuint driverControl, GLsizei bufSize, GLsizei *length, GLchar *driverControlString)
{
    Q_D(QOpenGLExtension_QCOM_driver_control);
    d->GetDriverControlStringQCOM(driverControl, bufSize, length, driverControlString);
}

inline void QOpenGLExtension_QCOM_driver_control::glEnableDriverControlQCOM(GLuint driverControl)
{
    Q_D(QOpenGLExtension_QCOM_driver_control);
    d->EnableDriverControlQCOM(driverControl);
}

inline void QOpenGLExtension_QCOM_driver_control::glDisableDriverControlQCOM(GLuint driverControl)
{
    Q_D(QOpenGLExtension_QCOM_driver_control);
    d->DisableDriverControlQCOM(driverControl);
}

class QOpenGLExtension_QCOM_extended_getPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP ExtGetTexturesQCOM)(GLuint *textures, GLint maxTextures, GLint *numTextures);
    void (QOPENGLF_APIENTRYP ExtGetBuffersQCOM)(GLuint *buffers, GLint maxBuffers, GLint *numBuffers);
    void (QOPENGLF_APIENTRYP ExtGetRenderbuffersQCOM)(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers);
    void (QOPENGLF_APIENTRYP ExtGetFramebuffersQCOM)(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers);
    void (QOPENGLF_APIENTRYP ExtGetTexLevelParameterivQCOM)(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params);
    void (QOPENGLF_APIENTRYP ExtTexObjectStateOverrideiQCOM)(GLenum target, GLenum pname, GLint param);
    void (QOPENGLF_APIENTRYP ExtGetTexSubImageQCOM)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *texels);
    void (QOPENGLF_APIENTRYP ExtGetBufferPointervQCOM)(GLenum target, GLvoid **params);
};

class QOpenGLExtension_QCOM_extended_get : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_QCOM_extended_get();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glExtGetTexturesQCOM(GLuint *textures, GLint maxTextures, GLint *numTextures);
    void glExtGetBuffersQCOM(GLuint *buffers, GLint maxBuffers, GLint *numBuffers);
    void glExtGetRenderbuffersQCOM(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers);
    void glExtGetFramebuffersQCOM(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers);
    void glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params);
    void glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param);
    void glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *texels);
    void glExtGetBufferPointervQCOM(GLenum target, GLvoid **params);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_QCOM_extended_get)
};

inline void QOpenGLExtension_QCOM_extended_get::glExtGetTexturesQCOM(GLuint *textures, GLint maxTextures, GLint *numTextures)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetTexturesQCOM(textures, maxTextures, numTextures);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtGetBuffersQCOM(GLuint *buffers, GLint maxBuffers, GLint *numBuffers)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetBuffersQCOM(buffers, maxBuffers, numBuffers);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtGetRenderbuffersQCOM(GLuint *renderbuffers, GLint maxRenderbuffers, GLint *numRenderbuffers)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetRenderbuffersQCOM(renderbuffers, maxRenderbuffers, numRenderbuffers);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtGetFramebuffersQCOM(GLuint *framebuffers, GLint maxFramebuffers, GLint *numFramebuffers)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetFramebuffersQCOM(framebuffers, maxFramebuffers, numFramebuffers);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtGetTexLevelParameterivQCOM(GLuint texture, GLenum face, GLint level, GLenum pname, GLint *params)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetTexLevelParameterivQCOM(texture, face, level, pname, params);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtTexObjectStateOverrideiQCOM(GLenum target, GLenum pname, GLint param)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtTexObjectStateOverrideiQCOM(target, pname, param);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtGetTexSubImageQCOM(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLvoid *texels)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetTexSubImageQCOM(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, texels);
}

inline void QOpenGLExtension_QCOM_extended_get::glExtGetBufferPointervQCOM(GLenum target, GLvoid **params)
{
    Q_D(QOpenGLExtension_QCOM_extended_get);
    d->ExtGetBufferPointervQCOM(target, params);
}

class QOpenGLExtension_QCOM_extended_get2Private : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP ExtGetShadersQCOM)(GLuint *shaders, GLint maxShaders, GLint *numShaders);
    void (QOPENGLF_APIENTRYP ExtGetProgramsQCOM)(GLuint *programs, GLint maxPrograms, GLint *numPrograms);
    GLboolean (QOPENGLF_APIENTRYP ExtIsProgramBinaryQCOM)(GLuint program);
    void (QOPENGLF_APIENTRYP ExtGetProgramBinarySourceQCOM)(GLuint program, GLenum shadertype, GLchar *source, GLint *length);
};

class QOpenGLExtension_QCOM_extended_get2 : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_QCOM_extended_get2();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glExtGetShadersQCOM(GLuint *shaders, GLint maxShaders, GLint *numShaders);
    void glExtGetProgramsQCOM(GLuint *programs, GLint maxPrograms, GLint *numPrograms);
    GLboolean glExtIsProgramBinaryQCOM(GLuint program);
    void glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar *source, GLint *length);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_QCOM_extended_get2)
};

inline void QOpenGLExtension_QCOM_extended_get2::glExtGetShadersQCOM(GLuint *shaders, GLint maxShaders, GLint *numShaders)
{
    Q_D(QOpenGLExtension_QCOM_extended_get2);
    d->ExtGetShadersQCOM(shaders, maxShaders, numShaders);
}

inline void QOpenGLExtension_QCOM_extended_get2::glExtGetProgramsQCOM(GLuint *programs, GLint maxPrograms, GLint *numPrograms)
{
    Q_D(QOpenGLExtension_QCOM_extended_get2);
    d->ExtGetProgramsQCOM(programs, maxPrograms, numPrograms);
}

inline GLboolean QOpenGLExtension_QCOM_extended_get2::glExtIsProgramBinaryQCOM(GLuint program)
{
    Q_D(QOpenGLExtension_QCOM_extended_get2);
    return d->ExtIsProgramBinaryQCOM(program);
}

inline void QOpenGLExtension_QCOM_extended_get2::glExtGetProgramBinarySourceQCOM(GLuint program, GLenum shadertype, GLchar *source, GLint *length)
{
    Q_D(QOpenGLExtension_QCOM_extended_get2);
    d->ExtGetProgramBinarySourceQCOM(program, shadertype, source, length);
}

class QOpenGLExtension_QCOM_tiled_renderingPrivate : public QAbstractOpenGLExtensionPrivate
{
public:
    void (QOPENGLF_APIENTRYP StartTilingQCOM)(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
    void (QOPENGLF_APIENTRYP EndTilingQCOM)(GLbitfield preserveMask);
};

class QOpenGLExtension_QCOM_tiled_rendering : public QAbstractOpenGLExtension
{
public:
    QOpenGLExtension_QCOM_tiled_rendering();

    bool initializeOpenGLFunctions() Q_DECL_FINAL;

    void glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask);
    void glEndTilingQCOM(GLbitfield preserveMask);

protected:
    Q_DECLARE_PRIVATE(QOpenGLExtension_QCOM_tiled_rendering)
};

inline void QOpenGLExtension_QCOM_tiled_rendering::glStartTilingQCOM(GLuint x, GLuint y, GLuint width, GLuint height, GLbitfield preserveMask)
{
    Q_D(QOpenGLExtension_QCOM_tiled_rendering);
    d->StartTilingQCOM(x, y, width, height, preserveMask);
}

inline void QOpenGLExtension_QCOM_tiled_rendering::glEndTilingQCOM(GLbitfield preserveMask)
{
    Q_D(QOpenGLExtension_QCOM_tiled_rendering);
    d->EndTilingQCOM(preserveMask);
}

#endif

QT_END_NAMESPACE

#endif // QT_NO_OPENGL

#endif
